##Writing vertex and fragment shaders

ShaderLab着色器包括的不仅仅是“硬件着色器”。他们做许多事情。它们描述了在材质检验员中显示的属性，包含不同图形硬件的多个着色器实现，配置固定函数硬件状态等等.。实际上可编程着色器--就像顶点和片段程序，只是整体的一部分ShaderLab的“着色”的概念。看看着色器教程的基本介绍。在这里，我们将调用低层次的硬件着色器着色器程序。

If you want to write shaders that interact with lighting, take a look at Surface Shaders documentation. For some examples, take a look at Vertex and Fragment Shader Examples. The rest of this page will assume shaders that do not interact with Unity lights (e.g. special effects, Image Effects etc.)
如果你想写灯光交互的着色器，查看Surface Shaders文档。对于一些例子，看看顶点和片段着色器的例子。本页面的其余部分将承担着色不与Unity灯光交互（如特殊效果，图像效果等）

着色程序是用CG / HLSL语言，通过嵌入“片段”在渲染文本，里面通过命令。他们通常看起来像这样：

```
  Pass {
      // ... the usual pass state setup ...
      
      CGPROGRAM
      // compilation directives for this snippet, e.g.:
      #pragma vertex vert
      #pragma fragment frag
      
      // the Cg/HLSL code itself
      
      ENDCG
      // ... the rest of pass setup ...
  }
```

####Cg/HLSL 片段

CG / HLSL程序片段被写入在CGPROGRAM和ENDCG之间。

在这段汇编指令的开始可以作为#编译指示语句。指示哪个着色器函数编译的指令：

\#pragma vertex name - 编译函数名称为顶点着色.

\#pragma fragment name - 编译函数名为片段材质.

\#pragma geometry name - 编译函数名作为DX10几何着色器。这个选项会自动打开#pragma target 4.0，描述如下。

\#pragma hull name - 编译函数名为DX11外壳着色器。这个选项会自动打开#pragma target 5.0，描述如下。

\#pragma domain name - 编译函数名为DX11域着色器。这个选项会自动打开#pragma target 5.0，描述如下。

####其他编译指令：

#pragma target name - which shader target to compile to. See Shader Compilation Targets page for details.

#pragma only_renderers space separated names - compile shader only for given renderers. By default shaders are compiled for all renderers. See Renderers below for details.

#pragma exclude_renderers space separated names - do not compile shader for given renderers. By default shaders are compiled for all renderers. See Renderers below for details.

#pragma multi_compile … - for working with multiple shader variants.
#pragma enable_d3d11_debug_symbols - generate debug information for shaders compiled for DirectX 11, this will allow you to debug shaders via Visual Studio 2012 (or higher) Graphics debugger.
#pragma hardware_tier_variants renderer name - generate multiple shader hardware variants of each compiled shader, for each hardware tier that could run the selected renderer. See Renderers below for details.
Each snippet must contain at least a vertex program and a fragment program. Thus #pragma vertex and #pragma fragment directives are required.

Compilation directives that don’t do anything starting with Unity 5.0 and can be safely removed: #pragma glsl, #pragma glsl_no_auto_normalization, #pragma profileoption, #pragma fragmentoption.

Rendering platforms

Unity supports several rendering APIs (e.g. Direct3D 9 and OpenGL), and by default all shader programs are compiled into all supported renderers. You can indicate which renderers to compile to using #pragma only_renderers or #pragma exclude_renderers directives. This is mostly useful in cases where you are explicitly using some shader language features that you know aren’t possible on some platforms. Supported renderer names are:

d3d9 - Direct3D 9
d3d11 - Direct3D 11/12
glcore - OpenGL 3.x/4.x
gles - OpenGL ES 2.0
gles3 - OpenGL ES 3.x
metal - iOS/Mac Metal
d3d11_9x - Direct3D 11 9.x feature level, as commonly used on WSA platforms
xboxone - Xbox One
ps4 - PlayStation 4
psp2 - PlayStation Vita
n3ds - Nintendo 3DS
wiiu - Nintendo Wii U
For example, this line would only compile shader into D3D9 mode:

#pragma only_renderers d3d9