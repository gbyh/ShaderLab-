##预定义的着色器预处理器宏

当编译着色器程序,Unity定义了几个预处理器宏。

####目标平台

		SHADER_API_D3D9 - Direct3D 9
		SHADER_API_D3D11 - desktop Direct3D 11
		SHADER_API_OPENGL - desktop OpenGL
		SHADER_API_GLES - OpenGL ES 2.0
		SHADER_API_GLES3 - OpenGL ES 3.0
		SHADER_API_METAL - iOS Metal
		SHADER_API_D3D11_9X - Direct3D 11 “feature level 9.x” target for Windows Store Apps & Windows Phone
		SHADER_API_PS4 - PlayStation 4
		SHADER_API_XBOXONE - Xbox One
		SHADER_API_PS3 - PlayStation 3
		SHADER_API_XBOX360 - Xbox 360
		SHADER_API_PSP2 - PlayStation Vita
		SHADER_API_PSM - PlayStation Mobile


通常SHADER_API_MOBILE被定义为所有“移动”平台(gl,GLES3、金属、PSP2)。

此外,SHADER_TARGET_GLSL定义当目标阴影语言是GLSL(总是对OpenGL / gl平台)。

####着色器目标模型

SHADER_TARGET宏将被定义为一个数值匹配材质目标编译模型(即匹配# pragma目标指令)。例如,SHADER_TARGET将30当编译到着色模型3.0。你可以用它在着色器代码条件检查,例如:

#if SHADER_TARGET < 30
    // less than shader model 3.0:
    // very limited shader capabilities, do some approximation
#else
    // decent capabilities, do a better thing
#endif


####Unity的版本

UNITY_VERSION macro will contain numeric value of Unity version, e.g. it will be 501 for Unity 5.0.1. This can be used for version comparisons if you need to write shaders that use different built-in shader functionality. For example, #if UNITY_VERSION >= 500 preprocessor check will only pass on versions 5.0.0 or later.
UNITY_VERSION宏将包含数值的Unity版本,如Unity5.0.1将达到501。这可以用于版本比较如果你需要编写着色器使用不同的内置着色器的功能。例如,#if UNITY_VERSION > = 500预处理器检查只会转嫁5.0.0或更高版本。

Platform difference helpers
平台差异助手

Direct use of these platform macros is discouraged, since it’s not very future proof. For example, if you’re writing a shader that checks for D3D9, then maybe in the future the check should be extended to include D3D11. Instead, Unity defines several helper macros (in HLSLSupport.cginc) to help with that.
直接使用这些平台宏气馁,因为它不是很未来的证据。例如,如果您正在编写一个着色器检查d3d 9,那么也许在将来检查应该扩展到包括D3D11。相反,Unity定义了几个助手宏(HLSLSupport.cginc)来帮助。

		UNITY_BRANCH - add this before conditional statements to hint the compiler that this should be compiled into an actual branch. Expands to [branch] when on HLSL platforms.
		UNITY_BRANCH——添加这个条件语句提示编译器之前,这应该是编译成一个实际的分支。扩大到HLSL平台上时(分支)。
		UNITY_FLATTEN - add this before conditional statements to hint the compiler that this should be flattened to avoid an actual branch instruction. Expands to [flatten] when on HLSL platforms.
		UNITY_FLATTEN——添加这个条件语句提示编译器之前,这应该被夷为平地,以避免实际的分支指令。扩大到HLSL平台上时(平)。
		UNITY_NO_SCREENSPACE_SHADOWS - defined on platforms that do not use cascaded screenspace shadowmaps (mobile platforms).
		UNITY_NO_SCREENSPACE_SHADOWS平台上定义,不使用级联screenspace shadowmaps(移动平台)。
		UNITY_NO_LINEAR_COLORSPACE - defined on platforms that do not support Linear color space (mobile platforms).
		UNITY_NO_LINEAR_COLORSPACE——定义平台不支持线性颜色空间(移动平台)。
		UNITY_NO_RGBM - defined on platforms where RGBM compression for lightmaps is not used (mobile platforms).
		UNITY_NO_RGBM——平台上定义RGBM压缩以及材质为不使用(移动平台)。
		UNITY_NO_DXT5nm - defined on platforms that do not use DXT5nm normal-map compression (mobile platforms).
		UNITY_NO_DXT5nm平台上定义,不使用DXT5nm法线贴图压缩(移动平台)。
		UNITY_FRAMEBUFFER_FETCH_AVAILABLE - defined on platforms where “framebuffer color fetch” functionality can be available (generally iOS platforms - OpenGL ES 2.0, 3.0 and Metal).
		UNITY_FRAMEBUFFER_FETCH_AVAILABLE——平台上定义“framebuffer颜色取”功能可以提供(一般iOS平台- OpenGL ES 2.0,3.0和金属)。
		UNITY_USE_RGBA_FOR_POINT_SHADOWS - defined on platforms where point light shadowmaps use RGBA textures with encoded depth (other platforms use single-channel floating point textures).
		UNITY_USE_RGBA_FOR_POINT_SHADOWS——平台上定义的点光源shadowmaps使用RGBA纹理编码深度(其他平台使用单通道浮点纹理)。
		UNITY_ATTEN_CHANNEL - which channel of light attenuation texture contains the data; used in per-pixel lighting code. Defined to either ‘r’ or ‘a’.
		UNITY_ATTEN_CHANNEL——通道的光衰减结构包含数据;用于逐照明代码。定义为“r”或“a”。
		UNITY_HALF_TEXEL_OFFSET - defined on platforms that need a half-texel offset adjustment in mapping texels to pixels (e.g. Direct3D 9).
		UNITY_HALF_TEXEL_OFFSET——上定义的平台,需要一个half-texel抵消texel映射到像素的调整(例如Direct3D 9)。
		UNITY_UV_STARTS_AT_TOP - always defined with value or 1 or 0; value of one is on platforms where texture V coordinate is zero at “top of the texture”. Direct3D-like platforms use value of 1; OpenGL-like platforms use value of 0.
		UNITY_UV_STARTS_AT_TOP——总是定义与价值或1或0;价值之一是V在平台上的纹理坐标是零在纹理的“顶级”。Direct3D-like平台使用的值为1;OpenGL-like平台使用值为0。
		UNITY_MIGHT_NOT_HAVE_DEPTH_TEXTURE - defined if a platform might emulate shadow maps or depth textures by manually rendering depth into a texture.
		UNITY_MIGHT_NOT_HAVE_DEPTH_TEXTURE——如果一个平台定义可能效仿阴影地图或深度纹理通过手动呈现深度纹理。
		UNITY_PROJ_COORD(a) - given a 4-component vector, return a texture coordinate suitable for projected texture reads. On most platforms this returns the given value directly.
		UNITY_PROJ_COORD(a)- 4组件向量,返回一个纹理坐标适合投影纹理读取。在大多数平台上直接返回给定的值。
		UNITY_NEAR_CLIP_VALUE - defined to the value of near clipping plane; Direct3D-like platforms use 0.0 while OpenGL-like platforms use –1.0.
		UNITY_NEAR_CLIP_VALUE——定义为剪切面附近的价值;Direct3D-like平台使用0.0而OpenGL-like平台使用-1.0。
		UNITY_VPOS_TYPE - data type requires for pixel position input (VPOS). float2 on D3D9, float4 elsewhere.
		UNITY_VPOS_TYPE——数据类型需要输入像素位置(VPOS)。float2 d3d 9,float4别处。
		UNITY_CAN_COMPILE_TESSELLATION - defined when the shader compiler “understands” tessellation shader HLSL syntax (currently only D3D11).
		UNITY_CAN_COMPILE_TESSELLATION——定义当着色器编译器“理解”镶嵌材质HLSL语法(目前只有D3D11)。
		UNITY_INITIALIZE_OUTPUT(type,name) - initialize variable name of given type to zero.
		UNITY_INITIALIZE_OUTPUT(类型、名称)——初始化变量名的特定类型为零。
		UNITY_COMPILER_HLSL, UNITY_COMPILER_HLSL2GLSL, UNITY_COMPILER_CG - indicates which shader compiler is being used to compile shaders. Respectively, Microsoft’s HLSL (used for DX9, DX11, XboxOne, Xbox360, WinRT), HLSL to GLSL translator (used for OpenGL & iOS/Android), and NVIDIA’s Cg (used for surface shader analysis and some Sony platforms). Use this if you run into very specific corner case shader syntax handling differences between the compilers, and want to write different code for each compiler.
		UNITY_COMPILER_HLSL UNITY_COMPILER_HLSL2GLSL UNITY_COMPILER_CG——表明,材质使用编译器编译着色器。分别,微软的HLSL(用于DX9 DX11、XboxOne Xbox360,WinRT),HLSL GLSL翻译(用于OpenGL和iOS和Android),和英伟达的Cg(用于表面材质分析和一些索尼平台)。使用这个如果你遇到非常具体的角落着色器语法处理编译器之间的差异,为每个编译器和想写不同的代码。

Shadow mapping macros
阴影映射宏

Declaring and sampling shadow maps can be very different depending on the platform, so Unity has several macros to help with that:
声明和抽样阴影地图可以根据不同平台,所以团结有几个宏帮助:

		UNITY_DECLARE_SHADOWMAP(tex) - declares a shadowmap texture variable with name “tex”.
		声明一个shadowmap纹理变量名称“tex”。
		UNITY_SAMPLE_SHADOW(tex,uv) - samples shadowmap texture “tex” at given “uv” coordinate (XY components are texture location, Z component is depth to compare with). Returns single float value with the shadow term in 0..1 range.
		shadowmap样本纹理“tex”给“uv”协调(XY组件结构位置、深度与Z分量)。返回单一的浮动值与阴影在0 . .1范围。
		UNITY_SAMPLE_SHADOW_PROJ(tex,uv) - similar to above, but does a projective shadowmap read. “uv” is a float4, all other components are divided by .w for doing the lookup.
		与上面类似,但是一个射影shadowmap阅读。“uv”是一个float4,除以所有其他组件。w进行查找。

Constant buffer macros
常数缓冲宏

Direct3D 11 groups all shader variables into “constant buffers”. Most of Unity’s built-in variables are already grouped, but for variables in your own shaders it might be more optimal to put them into separate constant buffers depending on expected frequency of updates.
Direct3D 11组所有着色器变量为“恒缓冲区”。大部分Unity的内置变量已经分组,但对于变量在自己的着色器可能是更优的放在单独的常数缓冲区根据预期的更新频率。

Use CBUFFER_START(name) and CBUFFER_END macros for that:
使用CBUFFER_START(名称)和CBUFFER_END宏:

CBUFFER_START(MyRarelyUpdatedVariables)
    float4 _SomeGlobalValue;
CBUFFER_END

Texture / Sampler declaration macros
宏纹理/取样器声明

Usually you would use texture2D in shader code to declare a texture & sampler pair. However, on some platforms (e.g. DX11) textures and samplers are separate objects; and maximum possible sampler count is quite limited. Unity has some macros to declare textures without samplers; and to sample a texture using a sampler from another texture. Use this if you end up running into sampler limits, and you know several of your textures can in fact share a sampler (sampler defines texture filtering & wrapping modes).
通常你会使用着色器代码中texture2D宣布一双质地和取样器。然而,在一些平台上(例如DX11)材质和取样器是独立的对象;和最大可能的取样器数量相当有限。Unity有一些宏声明没有采样纹理;和样本纹理使用取样器从另一个结构。使用这个如果你到取样器的限制,实际上你知道一些你的纹理可以共享一个取样器(取样器定义了纹理过滤&包装模式)。

		UNITY_DECLARE_TEX2D(name) - declares a texture + sampler pair.
		声明一个纹理+取样器。
		UNITY_DECLARE_TEX2D_NOSAMPLER(name) - declares a texture without a sampler.
		声明没有取样器的纹理。
		UNITY_SAMPLE_TEX2D(name,uv) - sample from a texture+sampler pair, using given texture coordinate.
		样本纹理+取样器,使用给定的纹理坐标。
		UNITY_SAMPLE_TEX2D_SAMPLER(name,samplername,uv) - sample from texture (name), using sampler from another texture (samplername).
		样本纹理(名字),使用采样器从另一个纹理(samplername)。
		
Surface shader pass indicators
表面材质通过指标

When Surface Shaders are compiled, they end up generating a lot of code for various passes to do lighting. When compiling each pass, one of the following macros is defined:
表面着色器编译时,最终生成大量的代码用于各种照明通过。当编译通过,一个下面的宏定义:

		UNITY_PASS_FORWARDBASE - forward rendering base pass (main directional light, lightmaps, SH).
		前方呈现基地通过(主要方向灯,以及材质,SH)。
		UNITY_PASS_FORWARDADD - forward rendering additive pass (one light per pass).
		向前呈现添加剂通过(每通过一盏灯)。
		UNITY_PASS_DEFERRED - deferred shading pass (renders g-buffer).
		递延阴影通过(呈现g-buffer)。
		UNITY_PASS_SHADOWCASTER - shadow caster and depth texture rendering pass.
		影子施法者和深度纹理渲染。
		UNITY_PASS_PREPASSBASE - legacy deferred lighting base pass (renders normals & specular exponent).
		遗留延迟照明基地通过(呈现法线和镜面指数)。
		UNITY_PASS_PREPASSFINAL - legacy deferred lighting final pass (applies lighting & textures).
		遗留延迟照明最终通过(适用于照明和纹理)。




