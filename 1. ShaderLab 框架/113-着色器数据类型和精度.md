##着色器数据类型和精度

在Unity的标准语言HLSL着色器，和一般的用数据类型的支持。然而，Unity有一些增加的HLSL的类型，特别是在移动平台上更好的支持。

####基本数据类型

在大多数计算着色器对浮点数进行（这将在常规编程语言如C #浮动）。浮点类型的几种变体：浮、半固定（以及向量/矩阵的变体，如half3和float4x4）。这些类型的精度不同（因此，性能或功耗使用）：


####高精度: float

最高精度浮点值；一般为32位（就像普通编程语言的浮点）。

全浮点精度一般用于世界空间位置，纹理坐标，或标量的计算涉及复杂的功能如三角或功率/指数。

####中等精度: half

中等精度浮点值；一般为16位（范围为60000至60000，精度约为十进制数字的3）。

半精度适用于短矢量、方向、物体空间位置、高动态范围颜色。

####低精度: fixed

最低精度不动点值。一般11位，范围为- 2至2和1 /精度。

固定的精度是有用的常规颜色（通常存储在常规纹理），并执行简单的操作。

####整数数据类型

整型（int数据类型）经常被用来作为循环计数器或数组索引。为了这个目的，他们通常工作在各种平台。

根据不同的平台，整数类型可能不支持的GPU。例如，Direct3D 9和OpenGL ES 2 GPU只在浮点数据，而看似简单的整数表达式（包括点或逻辑运算）可以进行相当复杂的浮点运算指令。

Direct3D 11, OpenGL ES 3, Metal and other modern platforms have proper support for integer data types, so using bit shifts and bit masking works as expected.

####混合成的 vector/matrix 类型

HLSL内置矢量和矩阵是从基本类型创建类型。例如，是一个三维向量float3。X、Y、Z分量，和half4是中等精度4D向量X，Y，Z，W组件。或者，向量可以使用R，G，B，一个颜色组件。

矩阵类型是建立在类似的方式；例如float4x4是4x4变换矩阵。请注意，有些平台只支持方阵，最明显的是OpenGL ES 2。

####精度、硬件支持和性能

一个复杂的浮动/一半/固定数据类型使用的是PC GPU总是高精度。这是所有PC（Windows / Mac / Linux）的GPU，不管你写的浮物，在你的着色器或半固定数据类型。他们总是计算所有的32位浮点精度。

半固定类型只能成为有关针对移动GPU，这些类型主要存在功率（有时表现）约束。记住，你需要测试你的着色器的手机看你是否正在运行精度的数值问题。

即使在移动GPU，支持不同精度不同GPU的家庭。这里的每个家庭将每个移动GPU浮点类型的概述（由使用它的比特数表示）：

|GPU Family|	float|	half|	fixed|
|:--|:--|:--|:--|
|PowerVR Series 6/7|	32|	16||
|PowerVR SGX 5xx|	32|	16|	11|
|Qualcomm Adreno 4xx/3xx|	32|	16||
|Qualcomm Adreno 2xx|	32 vertex 24 fragment|||
|ARM Mali T6xx/7xx|	32|	16||
|ARM Mali 400/450|	32 vertex 16 fragment|||
|NVIDIA X1|	32|	16||
|NVIDIA K1|	32|||
|NVIDIA Tegra 3/4|	32|	16||

Most modern mobile GPUs actually only support either 32-bit numbers (used for float type) or 16-bit numbers (used for both half and fixed types). Some older GPUs have different precisions for vertex shader and fragment shader computations.

Using lower precision can often be faster, either due to improved GPU register allocation, or due to special “fast path” execution units for certain lower-precision math operations. Even when there’s no raw performance advantage, using lower precision often uses less power on the GPU, leading to better battery life.

A general rule of thumb is to start with half precision for everything except positions and texture coordinates. Only increase precision if half precision is not enough for some parts of the computation.

####Support for infinities, NaNs and other special floating point values

Support for special floating point values can be different depending on which (mostly mobile) GPU family you’re running.

All PC GPUs that support Direct3D 10 support very well-specified IEEE 754 floating point standard. This means that float numbers behave exactly like they do in regular programming languages on the CPU.

Mobile GPUs can have slightly different levels of support. On some, dividing zero by zero might result in a NaN (“not a number”); on others it might result in infinity, zero or any other unspecified value. Make sure to test your shaders on the target device to check they are supported.