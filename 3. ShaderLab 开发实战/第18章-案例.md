	// Each #kernel tells which function to compile; you can have many kernel
	
	// 程序的入口点
	#pragma kernel CSMain 
	
	
	// 这声明了一个变量,Shader会利用这个变量包含的数据来工作,因为我们不初始利用网格数据来工作的,
	// 所以你必须明确的声明你的Compute Shader要读或者写哪些数据。数据类型前面的”RW”表明了这个变量是可读可写的。
	// Create a RenderTexture with enableRandomWrite flag and set it
	// with cs.SetTexture
	RWTexture2D<float4> Result;
	
	// 这一行指定了当前Compute Shader要产生的线程组的大小。
	// GPU通过创建同时运行的多个线程，拥有大规模并行处理能力。线程组规定了如何组织这些生成的线程。在上面的代码中，我们指定了我们希望每个线程组包含64个线程。就像一个二维数组一样。
	
	// 决定线程组的最优大小是一个很复杂的问题，这和你的目标硬件有很大的关系。
	// 一般来讲，把你的GPU当成一个流处理器的集合，其中的每一个处理器都能同时执行X个线程。
	// 一个处理器一次运行一个线程组,所以理想的情况，你希望你的线程组包含X个线程来充分利用处理器。
	// 我设置的值只是我根据我自己的情况,所以比起我给你们提供关于设置最优值的意见，你们还是自己去Google吧
	[numthreads(8,8,1)]
	
	// 内核程序函数根据运行的线程的ID来决定它应该处理哪一个像素.然后把一些数据写到缓冲里面去。
	void CSMain (uint3 id : SV_DispatchThreadID)
	{
		// TODO: insert actual code here!
	
		Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
	}
	
因为Compute Shader 不是利用网格数据来运行的,很显然我们不能把它挂在一个Mesh上让他运行。Compute Shader 需要在脚本中装配和调用,像下面一样:	

![](/assets/5214-10972-20.png)


这段代码有很多需要说明的地方,首先是在创建一个RenderTexture之前设置一下他的enableRandomWrite属性。这让你的Compute Shader拥有对这张纹理的写权限。如果不设置这个标记，在你的Shader中就不能把这个贴图作为写入目标。

接下来我们需要指定一下我们想调用Compute Shader中的哪个内核程序,FindKernel 方法需要一个字符串参数作为名字,这个名字可以Shader中相关内核程序的任意一个。就像我们在Shader一开头写的那个一样。一个Compute Shader在单个文件里可以拥有多个内核程序。

ComputeShader.SetTexture这个调用让我们可以把Shader需要的数据从CPU内存传递到GPU内存。才两个内存之前传递数据会给我们的程序引入延迟,程序效率被降低的程度正比于你需要传递的数据大小。由于这个原因。如果你打算每一帧都运行你的Shader，你最好认真的优化一下你真正需要操作多少数据。

传递给Dispatch方法的三个整数定义了,我们想生成的线程组数量。回想一下,每一个线程组的大小是通过Compute Shader中的numthreads来指定的,所以在上面的例子中,我们一共生成的线程数量如下：

　　　　　　　　　　　　 32*32个线程组*64(每个线程组中线程的数量) = 65536个线程。

这样下来最后就相当于一个线程对应我们要处理的RenderTexture中的一个像素,也就是内核程序的一次调用只处理一个像素。

现在我们知道了如何编写ComputeShader和如何处理纹理内存,让我们看看我们可以用这些东西做什么。


![](/assets/5214-10973-21.jpg)

结构缓冲(Structured Buffers)真是个好东西

处理纹理数据和我们之前的V&F Shader有点像，这让我并不是感到很激动。是时候去解放我们的GPU了,让它可以利用任何的数据。是的,这是可以做到的,就像它听起来的一样好。

结构缓冲就是一个只包含一种数据类型的数据序列，你可以创建一个存储float类型的结构缓冲,或者一个int类型的,但是不能创建一个同时存储float和int的。你可以像下面一样在ComputeShader中声明结构缓冲：

![](/assets/5214-10974-22.png)

让结构缓冲真正有趣的其实是它可以用来存储struct类型的数据。我们会在第二个例子中进行说明。

对于我们的的例子,我们打算给我们的ComputeShader传递一些顶点数据，同时再为每个顶点数据传递一个我们想对他进行何种变换的矩阵。我们可以通过分别创建两个缓冲来实现(一个用来存Vector3数据，一个用来存Matrix4X4数据)。我们很容易把两种结构抽象成一种点/矩阵对结构,那我们就这么办吧。

在我们的C#脚本中,我们定义了数据类型如下：

![](/assets/5214-10975-23.png)

