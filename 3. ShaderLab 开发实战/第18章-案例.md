	// Each #kernel tells which function to compile; you can have many kernel
	
	// 程序的入口点
	#pragma kernel CSMain 
	
	
	// 这声明了一个变量,Shader会利用这个变量包含的数据来工作,因为我们不初始利用网格数据来工作的,
	// 所以你必须明确的声明你的Compute Shader要读或者写哪些数据。数据类型前面的”RW”表明了这个变量是可读可写的。
	// Create a RenderTexture with enableRandomWrite flag and set it
	// with cs.SetTexture
	RWTexture2D<float4> Result;
	
	// 这一行指定了当前Compute Shader要产生的线程组的大小。
	// GPU通过创建同时运行的多个线程，拥有大规模并行处理能力。线程组规定了如何组织这些生成的线程。在上面的代码中，我们指定了我们希望每个线程组包含64个线程。就像一个二维数组一样。
	
	// 决定线程组的最优大小是一个很复杂的问题，这和你的目标硬件有很大的关系。
	// 一般来讲，把你的GPU当成一个流处理器的集合，其中的每一个处理器都能同时执行X个线程。
	// 一个处理器一次运行一个线程组,所以理想的情况，你希望你的线程组包含X个线程来充分利用处理器。
	// 我设置的值只是我根据我自己的情况,所以比起我给你们提供关于设置最优值的意见，你们还是自己去Google吧
	[numthreads(8,8,1)]
	
	// 内核程序函数根据运行的线程的ID来决定它应该处理哪一个像素.然后把一些数据写到缓冲里面去。
	void CSMain (uint3 id : SV_DispatchThreadID)
	{
		// TODO: insert actual code here!
	
		Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
	}
	
因为Compute Shader 不是利用网格数据来运行的,很显然我们不能把它挂在一个Mesh上让他运行。Compute Shader 需要在脚本中装配和调用,像下面一样:	

![](/assets/5214-10972-20.png)


这段代码有很多需要说明的地方,首先是在创建一个RenderTexture之前设置一下他的enableRandomWrite属性。这让你的Compute Shader拥有对这张纹理的写权限。如果不设置这个标记，在你的Shader中就不能把这个贴图作为写入目标。

接下来我们需要指定一下我们想调用Compute Shader中的哪个内核程序,FindKernel 方法需要一个字符串参数作为名字,这个名字可以Shader中相关内核程序的任意一个。就像我们在Shader一开头写的那个一样。一个Compute Shader在单个文件里可以拥有多个内核程序。

ComputeShader.SetTexture这个调用让我们可以把Shader需要的数据从CPU内存传递到GPU内存。才两个内存之前传递数据会给我们的程序引入延迟,程序效率被降低的程度正比于你需要传递的数据大小。由于这个原因。如果你打算每一帧都运行你的Shader，你最好认真的优化一下你真正需要操作多少数据。

传递给Dispatch方法的三个整数定义了,我们想生成的线程组数量。回想一下,每一个线程组的大小是通过Compute Shader中的numthreads来指定的,所以在上面的例子中,我们一共生成的线程数量如下：

　　　　　　　　　　　　 32*32个线程组*64(每个线程组中线程的数量) = 65536个线程。

这样下来最后就相当于一个线程对应我们要处理的RenderTexture中的一个像素,也就是内核程序的一次调用只处理一个像素。

现在我们知道了如何编写ComputeShader和如何处理纹理内存,让我们看看我们可以用这些东西做什么。


![](/assets/5214-10973-21.jpg)

结构缓冲(Structured Buffers)真是个好东西

处理纹理数据和我们之前的V&F Shader有点像，这让我并不是感到很激动。是时候去解放我们的GPU了,让它可以利用任何的数据。是的,这是可以做到的,就像它听起来的一样好。

结构缓冲就是一个只包含一种数据类型的数据序列，你可以创建一个存储float类型的结构缓冲,或者一个int类型的,但是不能创建一个同时存储float和int的。你可以像下面一样在ComputeShader中声明结构缓冲：

![](/assets/5214-10974-22.png)

让结构缓冲真正有趣的其实是它可以用来存储struct类型的数据。我们会在第二个例子中进行说明。

对于我们的的例子,我们打算给我们的ComputeShader传递一些顶点数据，同时再为每个顶点数据传递一个我们想对他进行何种变换的矩阵。我们可以通过分别创建两个缓冲来实现(一个用来存Vector3数据，一个用来存Matrix4X4数据)。我们很容易把两种结构抽象成一种点/矩阵对结构,那我们就这么办吧。

在我们的C#脚本中,我们定义了数据类型如下：

![](/assets/5214-10975-23.png)

同样我们也得在Shader中定义相应的结构，但是HLSL没有提供Matrix4x4或者Vector3类型。不过它有和他们拥有同样内存结构的数据类型。我们的Shader最后看起来会像下面一样：

![](/assets/5214-10976-24.png)

注意我们的线程组现在被组织成一个一维序列。线程组被设定成什么维度对性能是没有影响的，所以你可以选一个最适合你的程序的设定。

在脚本里面创建一个一个结构缓冲和我们前面创建纹理的那个例子有些不同。对于一个缓冲，你需要指定缓冲中每一个元素占用的字节大小，对于我们的例子中的struct,它占用的字节大小实际上就是我们用到的float数量(Vector用3个，Matrix用16个)乘以每个float占用的字节大小(4字节)。创建过程如下：

![](/assets/5214-10977-25.png)

现在我们需要把修改完的数据重新按照脚本中可以使用的格式传递回去,不想上面处理RenderTexture的例子。结构缓冲需要被明确的从GPU内存传递回CPU。以我的经验,这是你在使用ComputeShader时候会遇到的最影响性能的点。我目前发现的唯一缓解它的办法就是优化你的缓冲,从而让它在不影响你使用的情况下尽量的小,并且只有在你真的非常需要的时候才从shader中向外传递数据。

把数据传递会给CPU的代码非常的简单，你需要做的就是用一个相同类型的缓冲区接收它。我们修改上面的脚本让它把shader计算的结果回传到第二个序列中，如下：

![](/assets/5214-10978-26.png)

这就是全部内容了,你应该去看看profiler,确切的感受一下从GPU传递数据给CPU需要耗费多少时间.但是我发现,如果你用你的Compute Shader处理一个足够大的数据集的时候,这些代价是值得的。