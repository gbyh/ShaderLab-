	// Each #kernel tells which function to compile; you can have many kernels
	
	// 程序的入口点
	
	#pragma kernel CSMain 
	
	
	// 这声明了一个变量,Shader会利用这个变量包含的数据来工作,因为我们不初始利用网格数据来工作的,
	// 所以你必须明确的声明你的Compute Shader要读或者写哪些数据。数据类型前面的”RW”表明了这个变量是可读可写的。
	// Create a RenderTexture with enableRandomWrite flag and set it
	// with cs.SetTexture
	RWTexture2D<float4> Result;
	
	// 这一行指定了当前Compute Shader要产生的线程组的大小。
	// GPU通过创建同时运行的多个线程，拥有大规模并行处理能力。线程组规定了如何组织这些生成的线程。在上面的代码中，我们指定了我们希望每个线程组包含64个线程。就像一个二维数组一样。
	
	// 决定线程组的最优大小是一个很复杂的问题，这和你的目标硬件有很大的关系。
	// 一般来讲，把你的GPU当成一个流处理器的集合，其中的每一个处理器都能同时执行X个线程。
	// 一个处理器一次运行一个线程组,所以理想的情况，你希望你的线程组包含X个线程来充分利用处理器。
	// 我设置的值只是我根据我自己的情况,所以比起我给你们提供关于设置最优值的意见，你们还是自己去Google吧
	[numthreads(8,8,1)]
	
	// 内核程序函数根据运行的线程的ID来决定它应该处理哪一个像素.然后把一些数据写到缓冲里面去。
	void CSMain (uint3 id : SV_DispatchThreadID)
	{
		// TODO: insert actual code here!
	
		Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
	}